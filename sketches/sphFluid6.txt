import queasycam.*;

String projectTitle = "SPH Fluid Sim";

QueasyCam cam;

float floor = 695;
float ceiling = 0;
float left = 0;
float right = 1280;
float delta = 15;
float dtime = .01;
float gravity = 4;
float pull = .2;

float pointsize = 15;

float smooth = 35;
float stiff = 100000;
float stiffN = 2500;
float rest = .2;

int numpoints = 1000;

float grablength = 100;

float pressred = 5000*25;
float pressblue = 200*25;

boolean upgrav = false;
boolean downgrav = false;
boolean leftgrav = false;
boolean rightgrav = false;

float boundary_stride = 2*smooth;
float boundary_height = 2*smooth;

float m_p = rest*right*500.0/numpoints;

ArrayList<Line> boundary_lines;

float falling_box_bottom;
float falling_box_top;
float falling_box_left;
float falling_box_right;

float multiplier = 1.0;

float damping = 0.01;

class Line{
  public float x1;
  public float y1;
  public float x2;
  public float y2;
  public float nx;
  public float ny;
  public float length;
  public float velx;
  public float vely;
  public float px;
  public float py;
  Line(float x1, float y1, float x2, float y2){
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.length = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
    this.nx = (y2-y1)/this.length;
    this.ny = (x1-x2)/this.length;
    this.velx = 0.0;
    this.vely = 0.0;
    this.px = (x2-x1)/this.length;
    this.py = (y2-y1)/this.length;
  }
}


boolean falling_box_is_falling = false;

class Vector {
  float x, y, z;
  
  Vector(float a, float b, float c) {
    x = a;
    y = b;
    z = c;
  }
  
  void set(Vector v) {
    x = v.x;
    y = v.y;
    z = v.z;
  }
  
  void vnormalize() {
    float length = sqrt(pow(x,2) + pow(y, 2) + pow(z, 2));
    x /= length;
    y /= length;
    z /= length;
  }
}

Vector vadd(Vector a, Vector b) {
  return new Vector(a.x + b.x, a.y + b.y, a.z + b.z);
}

Vector vsubtract(Vector a, Vector b) {
  return new Vector(a.x - b.x, a.y - b.y, a.z - b.z);
}

Vector vmult(float a, Vector v) {
  return new Vector(a * v.x, a * v.y, a * v.z);
}

float vdot(Vector a, Vector b) {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}

Vector vcross(Vector a, Vector b) {
  return new Vector(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

float vdistance(Vector a, Vector b) {
  return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));
}


class Particle {
  float x, y;
  float oldx, oldy;
  float velx, vely;
  float dens, densN;
  float press, pressN;
  boolean grabbed;
  
  Particle(float x, float y) {
    this.x = x;
    this.y = y;
    oldx = x;
    oldy = y;
    velx = 0;
    vely = 0;
    dens = 0;
    densN = 0;
    press = 0;
    pressN = 0;
    grabbed = false;
  }
  
  void drawParticle() {
    float red = 50;
    float green = 50;
    float blue = 255;
    /*float diff = pressred - pressblue;
    float quad = diff / 4;
    if (press < pressblue) {
    } else if (press < pressblue + quad) {
      float segdiff = press - pressblue;
      green = segdiff / quad * 255;
    } else if (press < pressblue + 2 * quad) {
      float segdiff = press - pressblue - quad;
      green = 255;
      blue = 255 - (segdiff / quad * 255);
    } else if (press < pressblue + 3 * quad) {
      float segdiff = press - pressblue - 2 * quad;
      green = 255;
      blue = 50;
      red = segdiff / quad * 255;
    } else if (press < pressred) {
      float segdiff = press - pressblue - 3 * quad;
      red = 255;
      blue = 50;
      green = 255 - (segdiff / quad * 255);
    } else {
      red = 255;
      blue = 50;
    }*/
    stroke(red, green, blue);
    point(x, y);
  }
}



class Pair {
  Particle a, b;
  float q, q2, q3;
  
  Pair(Particle x, Particle y) {
    a = x;
    b = y;
    q = q2 = q3 = 0;
  }
}



class SphFluid {
  ArrayList<Particle> particles;
  
  int num;
  float ksmooth, kstiff, kstiffN, krest;
  float reach;
  
  SphFluid(int num, float ksm, float kst, float kstn, float kr, float reach) {
    this.num = num;
    ksmooth = ksm;
    kstiff = kst;
    kstiffN = kstn;
    krest = kr;
    this.reach = reach;
    particles = new ArrayList<Particle>();
    boundary_lines = new ArrayList<Line>();
    
    float interval = pointsize * 1.5;
    float initx = interval;
    float inity = interval;
    float row = 0;
    for (int i = 0; i < num; i++) {
      particles.add(new Particle(initx + row * 5, inity));
      initx += interval;
      if (initx > right - interval) {
        initx = interval;
        inity += interval;
        row++;
      }
    }
    
    boundary_lines.add(new Line(left, ceiling, left, floor));
    boundary_lines.add(new Line(left, floor, right, floor));
    boundary_lines.add(new Line(right, floor, right, ceiling));
  }
  
  
  void grab() {
    for (int i = 0; i < num; i++) {
      Particle p = particles.get(i);
      float dist = sqrt(pow(mouseX - p.x, 2) + pow(mouseY - p.y, 2));
      if (dist < reach) {
        p.grabbed = true;
      }
    }
  }
  
  void letGo() {
    for (int i = 0; i < num; i++) {
      Particle p = particles.get(i);
      p.grabbed = false;
    }
  }
  
  boolean checkAllBoundaries(Particle p){
    boolean first_check_failed = false;
    float old_x = 0.0;
    float old_y = 0.0;
    for(Line line : boundary_lines){
      float first_check = ((p.x-line.x1)*line.nx+(p.y-line.y1)*line.ny)*((p.oldx-line.x1)*line.nx+(p.oldy-line.y1)*line.ny);
      if(first_check <= 0){
        float second_check1 = abs((line.x1-p.oldx)*line.nx+(line.y1-p.oldy)*line.ny);
        float second_check2 = abs((p.x-p.oldx)*line.nx+(p.y-p.oldy)*line.ny);
        if(second_check2==0.0){
          float adding_vector1_x = 2*((line.x1-p.x)*line.nx+(line.y1-p.y)*line.ny)*line.nx;
          float adding_vector1_y = 2*((line.x1-p.x)*line.nx+(line.y1-p.y)*line.ny)*line.ny;
          float adding_vector2_x = -(p.velx*line.nx+p.vely*line.ny)*line.nx-damping*(p.velx*line.nx+p.vely*line.ny)*line.nx-damping*(line.velx*line.nx+line.vely*line.ny)*line.nx;
          float adding_vector2_y = -(p.velx*line.nx+p.vely*line.ny)*line.ny-damping*(p.velx*line.nx+p.vely*line.ny)*line.ny-damping*(line.velx*line.nx+line.vely*line.ny)*line.ny;
          old_x = p.x;
          old_y = p.y;
          first_check_failed = true;
          p.x += adding_vector1_x;
          p.y += adding_vector1_y;
          p.velx += adding_vector2_x;
          p.vely += adding_vector2_y;
        }
        else{
          float crossing_x = p.oldx+(p.x-p.oldx)*second_check1/second_check2;
          float crossing_y = p.oldy+(p.y-p.oldy)*second_check1/second_check2;
          float second_check3 = sqrt((crossing_x-line.x1)*(crossing_x-line.x1)+(crossing_y-line.y1)*(crossing_y-line.y1))/line.length;
          float second_check4 = (crossing_x-line.x1)*(line.x2-line.x1)+(crossing_y-line.y1)*(line.y2-line.y1);
          if(second_check3 <= 1 && second_check4 >= 0){
            float adding_vector1_x = 2*((line.x1-p.x)*line.nx+(line.y1-p.y)*line.ny)*line.nx;
            float adding_vector1_y = 2*((line.x1-p.x)*line.nx+(line.y1-p.y)*line.ny)*line.ny;
            float adding_vector2_x = -(p.velx*line.nx+p.vely*line.ny)*line.nx-damping*(p.velx*line.nx+p.vely*line.ny)*line.nx-damping*(line.velx*line.nx+line.vely*line.ny)*line.nx;
            float adding_vector2_y = -(p.velx*line.nx+p.vely*line.ny)*line.ny-damping*(p.velx*line.nx+p.vely*line.ny)*line.ny-damping*(line.velx*line.nx+line.vely*line.ny)*line.ny;
            old_x = crossing_x;
            old_y = crossing_y;
            first_check_failed = true;
            p.x += adding_vector1_x;
            p.y += adding_vector1_y;
            p.velx += adding_vector2_x;
            p.vely += adding_vector2_y;
          }
        }
      }
    }
    if(first_check_failed){
      for(Line line : boundary_lines){
        float first_check = ((p.x-line.x1)*line.nx+(p.y-line.y1)*line.ny)*((p.oldx-line.x1)*line.nx+(p.oldy-line.y1)*line.ny);
        if(first_check <= 0){
          float second_check1 = abs((line.x1-old_x)*line.nx+(line.y1-old_y)*line.ny);
          float second_check2 = abs((p.x-old_x)*line.nx+(p.y-old_y)*line.ny);
          if(second_check2==0.0){
            float adding_vector2_x = -(p.velx*line.nx+p.vely*line.ny)*line.nx-damping*(p.velx*line.nx+p.vely*line.ny)*line.nx-damping*(line.velx*line.nx+line.vely*line.ny)*line.nx;
            float adding_vector2_y = -(p.velx*line.nx+p.vely*line.ny)*line.ny-damping*(p.velx*line.nx+p.vely*line.ny)*line.ny-damping*(line.velx*line.nx+line.vely*line.ny)*line.ny;
            p.x += 2*line.nx;
            p.y += 2*line.ny;
            p.velx += adding_vector2_x;
            p.vely += adding_vector2_y;
          }
          else{
            float crossing_x = old_x+(p.x-old_x)*second_check1/second_check2;
            float crossing_y = old_y+(p.y-old_y)*second_check1/second_check2;
            float second_check3 = sqrt((crossing_x-line.x1)*(crossing_x-line.x1)+(crossing_y-line.y1)*(crossing_y-line.y1))/line.length;
            float second_check4 = (crossing_x-line.x1)*(line.x2-line.x1)+(crossing_y-line.y1)*(line.y2-line.y1);
            if(second_check3 <= 1 && second_check4 >= 0){
              float adding_vector2_x = -(p.velx*line.nx+p.vely*line.ny)*line.nx-damping*(p.velx*line.nx+p.vely*line.ny)*line.nx-damping*(line.velx*line.nx+line.vely*line.ny)*line.nx;
              float adding_vector2_y = -(p.velx*line.nx+p.vely*line.ny)*line.ny-damping*(p.velx*line.nx+p.vely*line.ny)*line.ny-damping*(line.velx*line.nx+line.vely*line.ny)*line.ny;
              p.x = crossing_x+2*line.nx;
              p.y = crossing_y+2*line.ny;
              p.velx += adding_vector2_x;
              p.vely += adding_vector2_y;
            }
          }
        }
      }
    }
    return true;
  }
  
  
  void updateParticles(float dt) {
    for (int z = 0; z < 2; z++) {
      ArrayList<Pair> pairs = new ArrayList<Pair>();
      ArrayList<Pair> boundary_pairs = new ArrayList<Pair>();
      
      if(falling_box_is_falling){
        if(falling_box_bottom < floor){
          float fall = 0;
          for(int i = 3; i<7; i++){
            boundary_lines.get(i).vely += gravity;
            fall = boundary_lines.get(i).vely * dt;
            boundary_lines.get(i).y1 += fall;
            boundary_lines.get(i).y2 += fall;
          }
          falling_box_bottom += fall;
          falling_box_top += fall;
        }
        else{
          for(int i = 3; i<7; i++){
            boundary_lines.get(i).vely = 0;
          }
        }
      }
    
      for (int i = 0; i < num; i++) {
        Particle p = particles.get(i);
        p.velx = (p.x - p.oldx) / dt;
        p.vely = (p.y - p.oldy) / dt;
        
        // gravity
        if (upgrav || leftgrav || rightgrav) {
          if (upgrav) {
            p.vely -= gravity;
          }
          if (leftgrav) {
            p.velx -= gravity;
          }
          if (rightgrav) {
            p.velx += gravity;
          }
          if (downgrav) {
            p.vely += gravity;
          }
        } else {
          p.vely += gravity;
        }
        
        // grab
        if (mousePressed && p.grabbed) {
          float vx = (mouseX - p.x);
          float vy = (mouseY - p.y);
          p.velx += pull * vx;
          p.vely += pull * vy;
        }
        
        checkAllBoundaries(p);
        
        p.oldx = p.x;
        p.oldy = p.y;
        p.x += p.velx * dt;
        p.y += p.vely * dt;
        p.dens = 0;
        p.densN = 0;
        p.velx = 0;
        p.vely = 0;
      }
      
      for (int i = 0; i < num; i++) {
        for (int j = 0; j < i; j++) {
          Particle p1 = particles.get(i);
          Particle p2 = particles.get(j);
          float dist = sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
          if (dist < ksmooth) {
            pairs.add(new Pair(p1, p2));
          }
        }
      }
      
      for (int i = 0; i < pairs.size(); i++) {
        Pair p = pairs.get(i);
        float dist = sqrt(pow(p.a.x - p.b.x, 2) + pow(p.a.y - p.b.y, 2));
        p.q = (float)(2 * Math.exp( -dist*dist / (smooth*smooth/4)) / Math.pow(smooth/2, 4) / Math.PI);
        p.q2 = (float)(Math.pow(1.0 / ((smooth/2)*Math.sqrt(Math.PI)), 2) * Math.exp( -dist*dist / (smooth*smooth/4)));
        p.a.dens += m_p*p.q2;
        p.b.dens += m_p*p.q2;
      }
      
      for(int i=0; i<num; i++){
        Particle p = particles.get(i);
        for(int j=0; j<boundary_lines.size(); j++){
          Line line = boundary_lines.get(j);
          float projection = (line.x1-p.x)*line.nx+(line.y1-p.y)*line.ny;
          float crossing_x = p.x + projection*line.nx;
          float crossing_y = p.y + projection*line.ny;
          float second_check3 = sqrt((crossing_x-line.x1)*(crossing_x-line.x1)+(crossing_y-line.y1)*(crossing_y-line.y1))/line.length;
          float second_check4 = (crossing_x-line.x1)*(line.x2-line.x1)+(crossing_y-line.y1)*(line.y2-line.y1);
          if(abs(projection) <= smooth/2 && second_check3 <= 1 && second_check4 >= 0){
            float sign = (projection > 0) ? 1 : -1;
            float new_p_x = p.x + (projection+sign*smooth/2)*line.nx;
            float new_p_y = p.y + (projection+sign*smooth/2)*line.ny;
            //float new_p_x = p.x + (projection)*line.nx;
            //float new_p_y = p.y + (projection)*line.ny;
            float dist_crossing_to_point1 = sqrt((crossing_x-line.x1)*(crossing_x-line.x1)+(crossing_y-line.y1)*(crossing_y-line.y1));
            float dist_crossing_to_point2 = sqrt((crossing_x-line.x2)*(crossing_x-line.x2)+(crossing_y-line.y2)*(crossing_y-line.y2));
            float width_1 = (dist_crossing_to_point1 > smooth) ? smooth : dist_crossing_to_point1;
            float width_2 = (dist_crossing_to_point2 > smooth) ? smooth : dist_crossing_to_point2;
            for(float e=smooth/10; e<width_1; e += 2*smooth/10){
              Particle new_p = new Particle(new_p_x-line.px*e, new_p_y-line.py*e);
              new_p.dens = multiplier*p.dens*smooth*(width_1+width_2)/10; 
              boundary_pairs.add(new Pair(p, new_p));
            }
            for(float e=smooth/10; e<width_2; e += 2*smooth/10){
              Particle new_p = new Particle(new_p_x+line.px*e, new_p_y+line.py*e);
              new_p.dens = multiplier*p.dens*smooth*(width_1+width_2)/10; 
              boundary_pairs.add(new Pair(p, new_p));
            }
          }
        }
      }

      for (int i = 0; i < boundary_pairs.size(); i++) {
        Pair p = boundary_pairs.get(i);
        float dist = sqrt(pow(p.a.x - p.b.x, 2) + pow(p.a.y - p.b.y, 2));
        p.q = (float)(2 * Math.exp( -dist*dist / (smooth*smooth/4)) / Math.pow(smooth/2, 4) / Math.PI);
        p.q2 = (float)(Math.pow(1.0 / ((smooth/2)*Math.sqrt(Math.PI)), 2) * Math.exp( -dist*dist / (smooth*smooth/4)));
        p.a.dens += (p.b.dens)*p.q2;
      }
      
      for (int i = 0; i < num; i++) {
        Particle p = particles.get(i);
        p.press = kstiff * (p.dens - krest);
      }
      
      for (int i = 0; i < pairs.size(); i++) {
        Pair p = pairs.get(i);
        float press = m_p*(p.a.press/(p.a.dens*p.a.dens) + p.b.press/(p.b.dens*p.b.dens));
        float displace = (press * p.q) * dt;
        float abx = (p.a.x - p.b.x);
        float aby = (p.a.y - p.b.y);
        p.a.velx += displace * abx;
        p.a.vely += displace * aby;
        p.b.velx -= displace * abx;
        p.b.vely -= displace * aby;
      }
      
      for (int i = 0; i < boundary_pairs.size(); i++) {
        Pair p = boundary_pairs.get(i);
        float press = (p.b.dens)*(p.a.press/(p.a.dens*p.a.dens));
        float displace = (press * p.q) * dt;
        float abx = (p.a.x - p.b.x);
        float aby = (p.a.y - p.b.y);
        p.a.velx += displace * abx;
        p.a.vely += displace * aby;
      }
      
      for (int i = 0; i < num; i++) {
        Particle p = particles.get(i);
        p.x += p.velx * dt;
        p.y += p.vely * dt;
      }
    }
  }
  
  void drawParticles() {
    strokeWeight(pointsize);
    for (int i = 0; i < num; i++) {
      Particle p = particles.get(i);
      p.drawParticle();
    }
    strokeWeight(1);
    stroke(255, 255, 0);
    for(Line line : boundary_lines){
      line(line.x1, line.y1, line.x2, line.y2);
    }
    //line(0, 500, 1280, 500);
    noStroke();
  }
}




SphFluid fluid = new SphFluid(numpoints, smooth, stiff, stiffN, rest, grablength);



void setup() {
 size(1280, 695, P3D);
 //cam = new QueasyCam(this);
 //cam.speed = 3;
 //cam.sensitivity = 1;
 noStroke();
}

void computePhysics(float dt) {
  fluid.updateParticles(dt);
}

void drawScene(){
  background(50, 51, 54);
  lights();

  fluid.drawParticles();
}

void draw() {
  float startFrame = millis(); 
  computePhysics(dtime); 
  float endPhysics = millis();
  
  drawScene();
  float endFrame = millis();
  delta = endFrame - startFrame;
  
  String runtimeReport = "Frame: "+str(endFrame-startFrame)+"ms,"+
        " Physics: "+ str(endPhysics-startFrame)+"ms,"+
        " FPS: "+ str(round(frameRate)) + "\n";
  surface.setTitle(projectTitle+ "  -  " +runtimeReport);
}

void keyPressed() {
  if (key == 32) {
    //swater = new ShallowWater(   50,    50,       10);
  }
  
  if (key == 'w') {
    upgrav = true;
  }
  if (key == 'a') {
    //leftgrav = true;
    falling_box_is_falling = true;
  }
  if (key == 'd') {
     float i=600;
     float j=500;
     for(; i<floor; i+=boundary_stride){
       j = 500;
       for(; j<600; j+=boundary_stride){
         
       }
     }
     falling_box_bottom = i;
     falling_box_left = 500;
     falling_box_top = 600;
     falling_box_right = j;
     
     boundary_lines.add(new Line(falling_box_left, falling_box_top, falling_box_left, falling_box_bottom));
     boundary_lines.add(new Line(falling_box_left, falling_box_bottom, falling_box_right, falling_box_bottom));
     boundary_lines.add(new Line(falling_box_right, falling_box_bottom, falling_box_right, falling_box_top));
     boundary_lines.add(new Line(falling_box_right, falling_box_top, falling_box_left, falling_box_top));
  }
  if (key == 's') {
    downgrav = true;
  }
}

void keyReleased() {
  if (key == 'w') {
    upgrav = false;
  }
  if (key == 'a') {
    //leftgrav = false;
  }
  if (key == 'd') {
    rightgrav = false;
  }
  if (key == 's') {
    downgrav = false;
  }
}

void mousePressed() {
  fluid.grab();
}

void mouseReleased() {
  fluid.letGo();
}
