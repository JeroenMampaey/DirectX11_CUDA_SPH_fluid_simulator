import queasycam.*;

String projectTitle = "SPH Fluid Sim";

QueasyCam cam;

float floor = 695;
float ceiling = 0;
float left = 0;
float right = 1280;
float delta = 15;
float dtime = .01;
float gravity = 4;
float pull = .2;

float pointsize = 15;

float smooth = 35;
float stiff = 100000;
float stiffN = 2500;
float rest = .2;

int numpoints = 1000;

float grablength = 100;

float pressred = 5000*25;
float pressblue = 200*25;

boolean upgrav = false;
boolean downgrav = false;
boolean leftgrav = false;
boolean rightgrav = false;

float boundary_stride = smooth/16;
float boundary_height = smooth;

float m_p = rest*right*500.0/numpoints;

ArrayList<Particle> falling_box_particles;
ArrayList<Line> boundary_lines;

  float falling_box_bottom;
  float falling_box_top;
  float falling_box_left;
  float falling_box_right;

class Line{
  public float x1;
  public float y1;
  public float x2;
  public float y2;
  public float nx;
  public float ny;
  public float length;
  public float velx;
  public float vely;
  Line(float x1, float y1, float x2, float y2){
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.length = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
    this.nx = (y2-y1)/this.length;
    this.ny = (x1-x2)/this.length;
    this.velx = 0.0;
    this.vely = 0.0;
  }
}


boolean falling_box_is_falling = false;

class Vector {
  float x, y, z;
  
  Vector(float a, float b, float c) {
    x = a;
    y = b;
    z = c;
  }
  
  void set(Vector v) {
    x = v.x;
    y = v.y;
    z = v.z;
  }
  
  void vnormalize() {
    float length = sqrt(pow(x,2) + pow(y, 2) + pow(z, 2));
    x /= length;
    y /= length;
    z /= length;
  }
}

Vector vadd(Vector a, Vector b) {
  return new Vector(a.x + b.x, a.y + b.y, a.z + b.z);
}

Vector vsubtract(Vector a, Vector b) {
  return new Vector(a.x - b.x, a.y - b.y, a.z - b.z);
}

Vector vmult(float a, Vector v) {
  return new Vector(a * v.x, a * v.y, a * v.z);
}

float vdot(Vector a, Vector b) {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}

Vector vcross(Vector a, Vector b) {
  return new Vector(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

float vdistance(Vector a, Vector b) {
  return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));
}


class Particle {
  float x, y;
  float oldx, oldy;
  float velx, vely;
  float dens, densN;
  float press, pressN;
  boolean grabbed;
  
  Particle(float x, float y) {
    this.x = x;
    this.y = y;
    oldx = x;
    oldy = y;
    velx = 0;
    vely = 0;
    dens = 0;
    densN = 0;
    press = 0;
    pressN = 0;
    grabbed = false;
  }
  
  void drawParticle(int kind) {
    if(kind==0){
      float red = 50;
      float green = 50;
      float blue = 255;
      float diff = pressred - pressblue;
      float quad = diff / 4;
      if (press < pressblue) {
      } else if (press < pressblue + quad) {
        float segdiff = press - pressblue;
        green = segdiff / quad * 255;
      } else if (press < pressblue + 2 * quad) {
        float segdiff = press - pressblue - quad;
        green = 255;
        blue = 255 - (segdiff / quad * 255);
      } else if (press < pressblue + 3 * quad) {
        float segdiff = press - pressblue - 2 * quad;
        green = 255;
        blue = 50;
        red = segdiff / quad * 255;
      } else if (press < pressred) {
        float segdiff = press - pressblue - 3 * quad;
        red = 255;
        blue = 50;
        green = 255 - (segdiff / quad * 255);
      } else {
        red = 255;
        blue = 50;
      }
      stroke(red, green, blue);
      point(x, y);
    }
    else if(kind==1){
      stroke(255, 255, 0);
      point(x, y);
    }
  }
}



class Pair {
  Particle a, b;
  float q, q2, q3;
  
  Pair(Particle x, Particle y) {
    a = x;
    b = y;
    q = q2 = q3 = 0;
  }
}



class SphFluid {
  ArrayList<Particle> particles;
  ArrayList<Particle> boundary_particles;
  
  int num;
  float ksmooth, kstiff, kstiffN, krest;
  float reach;
  
  SphFluid(int num, float ksm, float kst, float kstn, float kr, float reach) {
    this.num = num;
    ksmooth = ksm;
    kstiff = kst;
    kstiffN = kstn;
    krest = kr;
    this.reach = reach;
    particles = new ArrayList<Particle>();
    boundary_particles = new ArrayList<Particle>();
    falling_box_particles = new ArrayList<Particle>();
    boundary_lines = new ArrayList<Line>();
    
    float interval = pointsize * 1.5;
    float initx = interval;
    float inity = interval;
    float row = 0;
    for (int i = 0; i < num; i++) {
      particles.add(new Particle(initx + row * 5, inity));
      initx += interval;
      if (initx > right - interval) {
        initx = interval;
        inity += interval;
        row++;
      }
    }
    
    for(float i=0; i<right; i+=boundary_stride){
      boundary_particles.add(new Particle(i, floor));
    }
    for(float i=0; i<700; i+=boundary_stride){
       boundary_particles.add(new Particle(left, floor-i));
    }
    for(float i=0; i<700; i+=boundary_stride){
       boundary_particles.add(new Particle(right, floor-i));
    }
    
    boundary_lines.add(new Line(left+boundary_height/2, ceiling, left+boundary_height/2, floor-boundary_height/2));
    boundary_lines.add(new Line(left+boundary_height/2, floor-boundary_height/2, right-boundary_height/2, floor-boundary_height/2));
    boundary_lines.add(new Line(right-boundary_height/2, floor-boundary_height/2, right-boundary_height/2, ceiling));
  }
  
  
  void grab() {
    for (int i = 0; i < num; i++) {
      Particle p = particles.get(i);
      float dist = sqrt(pow(mouseX - p.x, 2) + pow(mouseY - p.y, 2));
      if (dist < reach) {
        p.grabbed = true;
      }
    }
  }
  
  void letGo() {
    for (int i = 0; i < num; i++) {
      Particle p = particles.get(i);
      p.grabbed = false;
    }
  }
  
  boolean checkAllBoundaries(Particle p){
    float damping = 0.1;
    for(Line line : boundary_lines){
      float first_check = ((p.x-line.x1)*line.nx+(p.y-line.y1)*line.ny)*((p.oldx-line.x1)*line.nx+(p.oldy-line.y1)*line.ny);
      if(first_check <= 0){
        float second_check1 = abs((line.x1-p.oldx)*line.nx+(line.y1-p.oldy)*line.ny);
        float second_check2 = abs((p.x-p.oldx)*line.nx+(p.y-p.oldy)*line.ny);
        if(second_check2==0.0){
          float adding_vector1_x = 2*((line.x1-p.x)*line.nx+(line.y1-p.y)*line.ny)*line.nx;
          float adding_vector1_y = 2*((line.x1-p.x)*line.nx+(line.y1-p.y)*line.ny)*line.ny;
          float adding_vector2_x = -(p.velx*line.nx+p.vely*line.ny)*line.nx-damping*(p.velx*line.nx+p.vely*line.ny)*line.nx-damping*(line.velx*line.nx+line.vely*line.ny)*line.nx;
          float adding_vector2_y = -(p.velx*line.nx+p.vely*line.ny)*line.ny-damping*(p.velx*line.nx+p.vely*line.ny)*line.ny-damping*(line.velx*line.nx+line.vely*line.ny)*line.ny;
          p.x += adding_vector1_x;
          p.y += adding_vector1_y;
          p.velx += adding_vector2_x;
          p.vely += adding_vector2_y;
        }
        else{
          float crossing_x = p.oldx+(p.x-p.oldx)*second_check1/second_check2;
          float crossing_y = p.oldy+(p.y-p.oldy)*second_check1/second_check2;
          float second_check3 = sqrt((crossing_x-line.x1)*(crossing_x-line.x1)+(crossing_y-line.y1)*(crossing_y-line.y1))/line.length;
          float second_check4 = (crossing_x-line.x1)*(line.x2-line.x1)+(crossing_y-line.y1)*(line.y2-line.y1);
          if(second_check3 <= 1 && second_check4 >= 0){
            float adding_vector1_x = 2*((line.x1-p.x)*line.nx+(line.y1-p.y)*line.ny)*line.nx;
            float adding_vector1_y = 2*((line.x1-p.x)*line.nx+(line.y1-p.y)*line.ny)*line.ny;
            float adding_vector2_x = -(p.velx*line.nx+p.vely*line.ny)*line.nx-damping*(p.velx*line.nx+p.vely*line.ny)*line.nx-damping*(line.velx*line.nx+line.vely*line.ny)*line.nx;
            float adding_vector2_y = -(p.velx*line.nx+p.vely*line.ny)*line.ny-damping*(p.velx*line.nx+p.vely*line.ny)*line.ny-damping*(line.velx*line.nx+line.vely*line.ny)*line.ny;
            p.x += adding_vector1_x;
            p.y += adding_vector1_y;
            p.velx += adding_vector2_x;
            p.vely += adding_vector2_y;
          }
        }
      }
    }
    return true;
  }
  
  
  void updateParticles(float dt) {
    for (int z = 0; z < 2; z++) {
      ArrayList<Pair> pairs = new ArrayList<Pair>();
      ArrayList<Pair> boundary_pairs = new ArrayList<Pair>();
      ArrayList<Pair> falling_box_pairs = new ArrayList<Pair>();
      
      if(falling_box_is_falling){
        if(falling_box_bottom < floor){
          float fall = 0;
          for(int i=0; i<falling_box_particles.size(); i++){
            Particle p = falling_box_particles.get(i);
            p.vely = (p.y - p.oldy) / dt;
            p.vely += gravity;
            p.oldy = p.y;
            fall = p.vely * dt;
            p.y += fall;
          }
          falling_box_bottom += fall;
          falling_box_top += fall;
          for(int i = 3; i<7; i++){
            boundary_lines.get(i).y1 += fall;
            boundary_lines.get(i).y2 += fall;
            boundary_lines.get(i).vely += gravity;
          }
        }
        else{
          for(int i = 3; i<7; i++){
            boundary_lines.get(i).vely = 0;
          }
        }
      }
    
      for (int i = 0; i < num; i++) {
        Particle p = particles.get(i);
        p.velx = (p.x - p.oldx) / dt;
        p.vely = (p.y - p.oldy) / dt;
        
        // gravity
        if (upgrav || leftgrav || rightgrav) {
          if (upgrav) {
            p.vely -= gravity;
          }
          if (leftgrav) {
            p.velx -= gravity;
          }
          if (rightgrav) {
            p.velx += gravity;
          }
          if (downgrav) {
            p.vely += gravity;
          }
        } else {
          p.vely += gravity;
        }
        
        // grab
        if (mousePressed && p.grabbed) {
          float vx = (mouseX - p.x);
          float vy = (mouseY - p.y);
          p.velx += pull * vx;
          p.vely += pull * vy;
        }
        
        checkAllBoundaries(p);
        
        p.oldx = p.x;
        p.oldy = p.y;
        p.x += p.velx * dt;
        p.y += p.vely * dt;
        p.dens = 0;
        p.densN = 0;
        p.velx = 0;
        p.vely = 0;
      }
      
      for (int i = 0; i < num; i++) {
        for (int j = 0; j < i; j++) {
          Particle p1 = particles.get(i);
          Particle p2 = particles.get(j);
          float dist = sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
          if (dist < ksmooth) {
            pairs.add(new Pair(p1, p2));
          }
        }
      }
      
      for (int i = 0; i < num; i++) {
        for (int j = 0; j < boundary_particles.size(); j++) {
          Particle p1 = particles.get(i);
          Particle p2 = boundary_particles.get(j);
          p2.dens = rest;
          float dist = sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
          if (dist < ksmooth) {
            boundary_pairs.add(new Pair(p1, p2));
          }
        }
      }
      
      for (int i = 0; i < num; i++) {
        for (int j = 0; j < falling_box_particles.size(); j++) {
          Particle p1 = particles.get(i);
          Particle p2 = falling_box_particles.get(j);
          p2.dens = rest;
          float dist = sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
          if (dist < ksmooth) {
            falling_box_pairs.add(new Pair(p1, p2));
          }
        }
      }
      
      for (int i = 0; i < pairs.size(); i++) {
        Pair p = pairs.get(i);
        float dist = sqrt(pow(p.a.x - p.b.x, 2) + pow(p.a.y - p.b.y, 2));
        p.q = (float)(2 * Math.exp( -dist*dist / (smooth*smooth/4)) / Math.pow(smooth/2, 4) / Math.PI);
        //p.q = (float)2*(1 - dist / ksmooth)/641.409;
        p.q2 = (float)(Math.pow(1.0 / ((smooth/2)*Math.sqrt(Math.PI)), 2) * Math.exp( -dist*dist / (smooth*smooth/4)));
        //p.q2 = pow(1 - dist / ksmooth, 2)/641.409;
        p.a.dens += m_p*p.q2;
        p.b.dens += m_p*p.q2;
      }
      
      float multiplier = 3.0;
      for (int i = 0; i < boundary_pairs.size(); i++) {
        Pair p = boundary_pairs.get(i);
        if(p.b.dens < multiplier*p.a.dens){
          p.b.dens = multiplier*p.a.dens;
        }
      }
      
      for (int i = 0; i < falling_box_pairs.size(); i++) {
        Pair p = falling_box_pairs.get(i);
        if(p.b.dens < multiplier*p.a.dens){
          p.b.dens = multiplier*p.a.dens;
        }
      }

      for (int i = 0; i < boundary_pairs.size(); i++) {
        Pair p = boundary_pairs.get(i);
        float dist = sqrt(pow(p.a.x - p.b.x, 2) + pow(p.a.y - p.b.y, 2));
        //p.q = 2*(1 - dist / ksmooth)/641.409;
        p.q = (float)(2 * Math.exp( -dist*dist / (smooth*smooth/4)) / Math.pow(smooth/2, 4) / Math.PI);
        //p.q2 = pow(1 - dist / ksmooth, 2)/641.409;
        p.q2 = (float)(Math.pow(1.0 / ((smooth/2)*Math.sqrt(Math.PI)), 2) * Math.exp( -dist*dist / (smooth*smooth/4)));
        p.a.dens += (boundary_stride*boundary_height*p.b.dens)*p.q2;
      }
      
      for (int i = 0; i < falling_box_pairs.size(); i++) {
        Pair p = falling_box_pairs.get(i);
        float dist = sqrt(pow(p.a.x - p.b.x, 2) + pow(p.a.y - p.b.y, 2));
        //p.q = 2*(1 - dist / ksmooth)/641.409;
        p.q = (float)(2 * Math.exp( -dist*dist / (smooth*smooth/4)) / Math.pow(smooth/2, 4) / Math.PI);
        //p.q2 = pow(1 - dist / ksmooth, 2)/641.409;
        p.q2 = (float)(Math.pow(1.0 / ((smooth/2)*Math.sqrt(Math.PI)), 2) * Math.exp( -dist*dist / (smooth*smooth/4)));
        p.a.dens += (boundary_stride*boundary_stride*p.b.dens)*p.q2;
      }
      
      for (int i = 0; i < num; i++) {
        Particle p = particles.get(i);
        p.press = kstiff * (p.dens - krest);
      }
      
      for (int i = 0; i < pairs.size(); i++) {
        Pair p = pairs.get(i);
        float press = m_p*(p.a.press/(p.a.dens*p.a.dens) + p.b.press/(p.b.dens*p.b.dens));
        float displace = (press * p.q) * dt;
        //float dist = sqrt(pow(p.a.x - p.b.x, 2) + pow(p.a.y - p.b.y, 2));
        float abx = (p.a.x - p.b.x);
        float aby = (p.a.y - p.b.y);
        p.a.velx += displace * abx;
        p.a.vely += displace * aby;
        p.b.velx -= displace * abx;
        p.b.vely -= displace * aby;
      }
      
      for (int i = 0; i < boundary_pairs.size(); i++) {
        Pair p = boundary_pairs.get(i);
        float press = (boundary_stride*boundary_height*p.b.dens)*(p.a.press/(p.a.dens*p.a.dens));
        float displace = (press * p.q) * dt;
        //float dist = sqrt(pow(p.a.x - p.b.x, 2) + pow(p.a.y - p.b.y, 2));
        float abx = (p.a.x - p.b.x);
        float aby = (p.a.y - p.b.y);
        p.a.velx += displace * abx;
        p.a.vely += displace * aby;
      }
      
      for (int i = 0; i < falling_box_pairs.size(); i++) {
        Pair p = falling_box_pairs.get(i);
        float press = (boundary_stride*boundary_stride*p.b.dens)*(p.a.press/(p.a.dens*p.a.dens));
        float displace = (press * p.q) * dt;
        //float dist = sqrt(pow(p.a.x - p.b.x, 2) + pow(p.a.y - p.b.y, 2));
        float abx = (p.a.x - p.b.x);
        float aby = (p.a.y - p.b.y);
        p.a.velx += displace * abx;
        p.a.vely += displace * aby;
      }
      
      for (int i = 0; i < num; i++) {
        Particle p = particles.get(i);
        p.x += p.velx * dt;
        p.y += p.vely * dt;
      }
    }
  }
  
  void drawParticles() {
    strokeWeight(pointsize);
    for (int i = 0; i < num; i++) {
      Particle p = particles.get(i);
      p.drawParticle(0);
    }
    for(int i=0; i<boundary_particles.size();i++){
      Particle p = boundary_particles.get(i);
      p.drawParticle(1);
    }
    for(int i=0; i<falling_box_particles.size(); i++){
      Particle p = falling_box_particles.get(i);
      p.drawParticle(1);
    }
    noStroke();
  }
}




SphFluid fluid = new SphFluid(numpoints, smooth, stiff, stiffN, rest, grablength);



void setup() {
 size(1280, 695, P3D);
 //cam = new QueasyCam(this);
 //cam.speed = 3;
 //cam.sensitivity = 1;
 noStroke();
}

void computePhysics(float dt) {
  fluid.updateParticles(dt);
}

void drawScene(){
  background(50, 51, 54);
  lights();

  fluid.drawParticles();
}

void draw() {
  float startFrame = millis(); 
  computePhysics(dtime); 
  float endPhysics = millis();
  
  drawScene();
  float endFrame = millis();
  delta = endFrame - startFrame;
  
  String runtimeReport = "Frame: "+str(endFrame-startFrame)+"ms,"+
        " Physics: "+ str(endPhysics-startFrame)+"ms,"+
        " FPS: "+ str(round(frameRate)) + "\n";
  surface.setTitle(projectTitle+ "  -  " +runtimeReport);
}

void keyPressed() {
  if (key == 32) {
    //swater = new ShallowWater(   50,    50,       10);
  }
  
  if (key == 'w') {
    upgrav = true;
  }
  if (key == 'a') {
    //leftgrav = true;
    falling_box_is_falling = true;
  }
  if (key == 'd') {
    float i=200;
     float j=500;
     for(; i<300; i+=boundary_stride){
       j = 500;
       for(; j<600; j+=boundary_stride){
         falling_box_particles.add(new Particle(j, i));
       }
     }
     falling_box_bottom = i;
     falling_box_left = 500;
     falling_box_top = 200;
     falling_box_right = j;
     
     boundary_lines.add(new Line(falling_box_left-boundary_stride/2, falling_box_top-boundary_stride/2, falling_box_left-boundary_stride/2, falling_box_bottom+boundary_stride/2));
     boundary_lines.add(new Line(falling_box_left-boundary_stride/2, falling_box_bottom+boundary_stride/2, falling_box_right+boundary_stride/2, falling_box_bottom+boundary_stride/2));
     boundary_lines.add(new Line(falling_box_right+boundary_stride/2, falling_box_bottom+boundary_stride/2, falling_box_right+boundary_stride/2, falling_box_top-boundary_stride/2));
     boundary_lines.add(new Line(falling_box_right+boundary_stride/2, falling_box_top-boundary_stride/2, falling_box_left-boundary_stride/2, falling_box_top-boundary_stride/2));
  }
  if (key == 's') {
    downgrav = true;
  }
}

void keyReleased() {
  if (key == 'w') {
    upgrav = false;
  }
  if (key == 'a') {
    //leftgrav = false;
  }
  if (key == 'd') {
    rightgrav = false;
  }
  if (key == 's') {
    downgrav = false;
  }
}

void mousePressed() {
  fluid.grab();
}

void mouseReleased() {
  fluid.letGo();
}
